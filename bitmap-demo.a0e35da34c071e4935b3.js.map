{"version":3,"sources":["webpack:///./src/js/bitmap-demo.js","webpack:///./src/js/workers/bitmap-worker.js"],"names":["window","toggleMobileNav","document","getElementById","CanvasIds","BITMAP_LOW_RES","transferControlToOffscreen","alert","unsupportedOffscreenCanvasAlertMessage","reqId","NAME","worker","Worker","name","bitmapsConfig","ctx","getContext","resolution","width","height","BITMAP_MEDIUM_RES","BITMAP_HIGH_RES","resolutions","reduce","accumul","curVal","style","messages","querySelector","errorInWorker","undefined","onmessage","event","text","data","source","action","console","log","li","makeLi","appendChild","lastChild","scrollIntoView","WorkerAction","BITMAPS","bitmaps","payload","forEach","cfg","i","transferFromImageBitmap","TERMINATE_ME","terminate","warn","cancelAnimationFrame","NOTIFY","onerror","message","MainThreadAction","INIT_WORKER_STATE","sceneName","postMessage","requestLoop","tick","REQUEST_BITMAPS","requestAnimationFrame","module","exports"],"mappings":"seAMAA,OAAOC,gBAAkBA,IAGtBC,SAASC,eAAeC,IAAUC,gBAAgBC,4BAEnDC,MAAMC,KAKR,WACE,IAmCIC,EAnCEC,EAAO,cAEPC,EAAS,IAAIC,OAAO,EAA8B,CACtDC,KAAM,kDAKFC,EAAgB,CACpB,CACEC,IAAKb,SACFC,eAAeC,IAAUC,gBACzBW,WAAW,kBACdC,WAAY,CAAEC,MAAO,IAAKC,OAAQ,KAEpC,CACEJ,IAAKb,SACFC,eAAeC,IAAUgB,mBACzBJ,WAAW,kBACdC,WAAY,CAAEC,MAAO,IAAKC,OAAQ,MAEpC,CACEJ,IAAKb,SACFC,eAAeC,IAAUiB,iBACzBL,WAAW,kBACdC,WAAY,CAAEC,MAAO,KAAMC,OAAQ,OAIjCG,EAAcR,EAAcS,QAAO,SAACC,EAASC,GACjD,kBAAWD,GAAX,CAAoBC,EAAOR,eAC1B,IAEGS,EAAQ,oCAIRC,EAAWzB,SAAS0B,cAAc,gBAwCpCC,OAAgBC,EAKpBnB,EAAOoB,UA3CW,SAAAC,GAChB,IAAMC,EAAO,IAAH,OAAOvB,EAAP,gBAAmBsB,EAAME,KAAKC,OAA9B,eAA2CH,EAAME,KAAKE,QAChEC,QAAQC,IAAR,YAAiBL,GAAQP,GAEzB,IAAMa,EAAKC,YAAO,CAAEP,OAAMP,UAI1B,OAHAC,EAASc,YAAYF,GACrBZ,EAASe,UAAUC,iBAEXX,EAAME,KAAKE,QACjB,KAAKQ,IAAaC,QAAS,IACjBC,EAAYd,EAAME,KAAKa,QAAvBD,QACRhC,EAAckC,SAAQ,SAACC,EAAKC,GAC1BD,EAAIlC,IAAIoC,wBAAwBL,EAAQI,OAE1C,MAEF,KAAKN,IAAaQ,aAChBzC,EAAO0C,YACPhB,QAAQiB,KAAR,UAAgB5C,EAAhB,uBAAmCsB,EAAME,KAAKC,SAG9CoB,qBAAqB9C,GACrB,MAEF,KAAKmC,IAAaY,OAEhB,MAEF,QACEnB,QAAQiB,KAAR,UAAgB5C,EAAhB,4CAAgEsB,KAetErB,EAAO8C,QALS,SAAAzB,GACdH,EAAgBG,GAMlB,IAAM0B,EAAU,CACdtB,OAAQuB,IAAiBC,kBAKzBb,QAAS,CAAE7B,MAAO,KAAMC,OAAQ,IAAK0C,UAAW,iBAChD1B,OAAQzB,GAEVC,EAAOmD,YAAYJ,GAEnB,IAAMnB,EAAKC,YAAO,CAChBP,KAAM,IAAF,OAAMvB,EAAN,2BAA0BgD,EAAQtB,QACtCV,MAAO,oCAETC,EAASc,YAAYF,GACrBZ,EAASe,UAAUC,kBAMC,SAAdoB,EAAcC,GAClBrD,EAAOmD,YAAY,CACjB1B,OAAQuB,IAAiBM,gBACzBlB,QAAS,CACPzB,eAEFa,OAAQzB,IAEViB,EAASc,YACPD,YAAO,CACLP,KAAM,IAAF,OAAMvB,EAAN,2BAA0BiD,IAAiBM,iBAC/CvC,MAAO,qCAGXC,EAASe,UAAUC,iBACnBlC,EAAQyD,sBAAsBH,GAC1BlC,GACF0B,qBAAqB9C,GAIzBsD,GAjIF,I,qCChBAI,EAAOC,QAAU,IAA0B,iF","file":"bitmap-demo.a0e35da34c071e4935b3.js","sourcesContent":["import { MainThreadAction, WorkerAction } from \"./worker-actions\";\nimport { toggleMobileNav } from \"./components/navbar\";\nimport { makeLi } from \"./helpers\";\nimport { CanvasIds, unsupportedOffscreenCanvasAlertMessage } from \"./constants\";\nimport \"../css/index.css\";\n\nwindow.toggleMobileNav = toggleMobileNav;\n\nif (\n  !document.getElementById(CanvasIds.BITMAP_LOW_RES).transferControlToOffscreen\n) {\n  alert(unsupportedOffscreenCanvasAlertMessage);\n}\n\n// TODO: preload the web worker script with resource hints. Or is it done automatically by webpack's worker-loader?\n// const workerUrl = document.querySelector(\"[rel=preload][as=script]\").href;\n(function iife() {\n  const NAME = \"Main thread\";\n\n  const worker = new Worker(\"./workers/bitmap-worker.js\", {\n    name: \"Dedicated worker global scope (bitmap worker)\",\n    type: \"module\",\n  });\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmapRenderingContext\n  const bitmapsConfig = [\n    {\n      ctx: document\n        .getElementById(CanvasIds.BITMAP_LOW_RES)\n        .getContext(\"bitmaprenderer\"),\n      resolution: { width: 160, height: 90 },\n    },\n    {\n      ctx: document\n        .getElementById(CanvasIds.BITMAP_MEDIUM_RES)\n        .getContext(\"bitmaprenderer\"),\n      resolution: { width: 640, height: 480 },\n    },\n    {\n      ctx: document\n        .getElementById(CanvasIds.BITMAP_HIGH_RES)\n        .getContext(\"bitmaprenderer\"),\n      resolution: { width: 1024, height: 768 },\n    },\n  ];\n\n  const resolutions = bitmapsConfig.reduce((accumul, curVal) => {\n    return [...accumul, curVal.resolution];\n  }, []);\n\n  const style = \"color: green; font-weight: normal\";\n\n  let reqId;\n\n  const messages = document.querySelector(\".messages ol\");\n\n  const onMessage = event => {\n    const text = `[${NAME} <-- ${event.data.source}] - ${event.data.action}`;\n    console.log(`%c${text}`, style);\n\n    const li = makeLi({ text, style });\n    messages.appendChild(li);\n    messages.lastChild.scrollIntoView();\n\n    switch (event.data.action) {\n      case WorkerAction.BITMAPS: {\n        const { bitmaps } = event.data.payload;\n        bitmapsConfig.forEach((cfg, i) => {\n          cfg.ctx.transferFromImageBitmap(bitmaps[i]);\n        });\n        break;\n      }\n      case WorkerAction.TERMINATE_ME: {\n        worker.terminate();\n        console.warn(`${NAME} terminated ${event.data.source}`);\n        // If the web worker is no longer listening, it makes no sense to keep\n        // sending him messages in requestLoop;\n        cancelAnimationFrame(reqId);\n        break;\n      }\n      case WorkerAction.NOTIFY: {\n        // we have already printed the message, so we simply break.\n        break;\n      }\n      default: {\n        console.warn(`${NAME} received a message that does not handle`, event);\n      }\n    }\n  };\n\n  // When a runtime error occurs in the worker, its onerror event handler is\n  // called. It receives an event named error which implements the ErrorEvent\n  // interface.\n  // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent\n  let errorInWorker = undefined;\n  const onError = event => {\n    errorInWorker = event;\n  };\n\n  worker.onmessage = onMessage;\n  worker.onerror = onError;\n\n  const message = {\n    action: MainThreadAction.INIT_WORKER_STATE,\n    // width and height are for the OffscreenCanvas created by the web worker.\n    // They will also be the width and height of the generated ImageBitmap\n    // returned by the web-worker and rendered into the canvas that has a\n    // `bitmaprenderer` context.\n    payload: { width: 1024, height: 768, sceneName: \"My Test Scene\" },\n    source: NAME,\n  };\n  worker.postMessage(message);\n\n  const li = makeLi({\n    text: `[${NAME} --> worker] ${message.action}`,\n    style: \"color: red; font-weight: normal\",\n  });\n  messages.appendChild(li);\n  messages.lastChild.scrollIntoView();\n\n  // Up until recently, requestAnimationFrame was not available in web workers,\n  // so using requestAnimationFrame in the main thread was one of the possible\n  // workarounds. Now I think it would be better to move requestAnimationFrame\n  // to the web worker, so the main thread has less work to do.\n  const requestLoop = tick => {\n    worker.postMessage({\n      action: MainThreadAction.REQUEST_BITMAPS,\n      payload: {\n        resolutions,\n      },\n      source: NAME,\n    });\n    messages.appendChild(\n      makeLi({\n        text: `[${NAME} --> worker] ${MainThreadAction.REQUEST_BITMAPS}`,\n        style: \"color: red; font-weight: normal\",\n      })\n    );\n    messages.lastChild.scrollIntoView();\n    reqId = requestAnimationFrame(requestLoop);\n    if (errorInWorker) {\n      cancelAnimationFrame(reqId);\n    }\n  };\n\n  requestLoop();\n})();\n","module.exports = __webpack_public_path__ + \"Dedicated worker global scope (bitmap worker).3eafb08bf18e451112f8.worker.js\""],"sourceRoot":""}