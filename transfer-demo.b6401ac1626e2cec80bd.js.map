{"version":3,"sources":["webpack:///./src/js/transfer-demo.js","webpack:///./src/js/workers/transfer-worker.js?931c","webpack:///./src/js/workers/transfer-worker.js"],"names":["window","toggleMobileNav","NAME","worker","Worker","name","canvas","document","getElementById","CanvasIds","TRANSFER_CONTROL","addEventListener","event","console","warn","log","messages","querySelector","onmessage","text","data","source","action","style","li","makeLi","appendChild","lastChild","scrollIntoView","WorkerAction","NOTIFY","payload","info","TERMINATE_ME","terminate","onerror","error","alert","message","filename","setAttribute","transferControlToOffscreen","unsupportedOffscreenCanvasAlertMessage","offscreenCanvas","MainThreadAction","INIT_WORKER_STATE","sceneName","transfer","postMessage","styleFromWorker","ButtonIds","START_RENDER_LOOP","STOP_RENDER_LOOP","TERMINATE_WORKER","INSTANTIATE_WORKER","workerId","Math","ceil","random","oldCanvas","newCanvas","cloneNode","parentNode","replaceChild","anotherOffscreenCanvas","msg","module","exports"],"mappings":"yFAAA,0DAUAA,OAAOC,gBAAkBA,IAKzB,WAAiB,WACTC,EAAO,cAETC,EAAS,IAAIC,OAAO,EAAgC,CACtDC,KAAM,6BAIFC,EAASC,SAASC,eAAeC,IAAUC,kBAkBjDV,OAAOW,iBAAiB,UAdH,SAAAC,GACnBC,QAAQC,KAAKF,GAEbC,QAAQE,IACN,eAGA,MASJ,IAAMC,EAAWT,SAASU,cAAc,gBA+BxCd,EAAOe,UA7BW,SAAAN,GAChB,IAAMO,EAAO,IAAH,OAAOjB,EAAP,gBAAmBU,EAAMQ,KAAKC,OAA9B,eAA2CT,EAAMQ,KAAKE,QAC1DC,EAAQ,oCACdV,QAAQE,IAAR,YAAiBI,GAAQI,GACzB,IAAMC,EAAKC,YAAO,CAChBN,OACAI,UAKF,OAHAP,EAASU,YAAYF,GACrBR,EAASW,UAAUC,iBAEXhB,EAAMQ,KAAKE,QACjB,KAAKO,IAAaC,OAChBjB,QAAQE,IAAIH,EAAMQ,KAAKW,QAAQC,MAC/B,MACF,KAAKH,IAAaI,aAChB9B,EAAO+B,YACPrB,QAAQC,KAAK,qCACb,MACF,QACED,QAAQC,KAAR,UAAgBZ,EAAhB,4CAAgEU,KAUtET,EAAOgC,QANS,SAAAvB,GACdC,QAAQuB,MAAM,sBAAuBxB,GACrCyB,MAAM,GAAD,OAAIzB,EAAM0B,QAAV,cAAuB1B,EAAM2B,SAA7B,6BAePjC,EAAOkC,aAAa,QAAS,QAC7BlC,EAAOkC,aAAa,SAAU,OACzBlC,EAAOmC,4BACVJ,MAAMK,KAER,IAAMC,EAAkBrC,EAAOmC,6BACzBH,EAAU,CACdhB,OAAQsB,IAAiBC,kBACzBd,QAAS,CAAEzB,OAAQqC,EAAiBG,UAAW,YAC/CzB,OAAQnB,GAEJ6C,EAAW,CAACJ,GAClBxC,EAAO6C,YAAYV,EAASS,GAE5B,IAAME,EAAkB,kCACxBjC,EAASU,YACPD,YAAO,CACLN,KAAM,IAAF,OAAMjB,EAAN,2BAA0BoC,EAAQhB,QACtCC,MAAO0B,KAGXjC,EAASW,UAAUC,iBAECrB,SAASC,eAAe0C,IAAUC,mBAC1CxC,iBAAiB,SAAS,WACpCR,EAAO6C,YAAY,CACjB1B,OAAQsB,IAAiBO,kBACzB9B,OAAQnB,IAEVc,EAASU,YACPD,YAAO,CACLN,KAAM,IAAF,OAAMjB,EAAN,2BAA0B0C,IAAiBO,mBAC/C5B,MAAO0B,KAGXjC,EAASW,UAAUC,oBAGFrB,SAASC,eAAe0C,IAAUE,kBAC1CzC,iBAAiB,SAAS,WACnCR,EAAO6C,YAAY,CACjB1B,OAAQsB,IAAiBQ,iBACzB/B,OAAQnB,IAEVc,EAASU,YACPD,YAAO,CACLN,KAAM,IAAF,OAAMjB,EAAN,2BAA0B0C,IAAiBQ,kBAC/C7B,MAAO0B,KAGXjC,EAASW,UAAUC,oBAGGrB,SAASC,eAAe0C,IAAUG,kBAC1C1C,iBAAiB,SAAS,WACxCR,EAAO+B,eAGiB3B,SAASC,eACjC0C,IAAUI,oBAEM3C,iBAAiB,SAAS,WAG1C,IAAM4C,EAAWC,KAAKC,KAAqB,IAAhBD,KAAKE,UAChCvD,EAAS,IAAIC,OAAO,EAAgC,CAClDC,KAAM,mBAAF,OAAqBkD,KAM3B,IAAMI,EAAYpD,SAASC,eAAeC,IAAUC,kBAC9CkD,EAAYD,EAAUE,YAC5BF,EAAUG,WAAWC,aAAaH,EAAWD,GAG7C,IAAMK,EAAyBJ,EAAUnB,6BACnCwB,EAAM,CACV3C,OAAQsB,IAAiBC,kBACzBd,QAAS,CAAEzB,OAAQ0D,EAAwBlB,UAAW,iBACtDzB,OAAQnB,GAEVC,EAAO6C,YAAYiB,EAAK,CAACD,OA1J7B,I,2CCfAE,EAAOC,QAAU,IAA0B,2D,mBCA3CD,EAAOC,QAAU,IAA0B,qC","file":"transfer-demo.b6401ac1626e2cec80bd.js","sourcesContent":["import { toggleMobileNav } from \"./components/navbar\";\nimport { makeLi } from \"./helpers\";\nimport {\n  ButtonIds,\n  CanvasIds,\n  unsupportedOffscreenCanvasAlertMessage,\n} from \"./constants\";\nimport { MainThreadAction, WorkerAction } from \"./worker-actions\";\nimport \"../css/index.css\";\n\nwindow.toggleMobileNav = toggleMobileNav;\n\n// TODO: preload the web worker script with resource hints. Or is it done automatically by webpack's worker-loader?\n// const workerUrl = document.querySelector(\"[rel=preload][as=script]\").href;\n\n(function iife() {\n  const NAME = \"Main thread\";\n\n  let worker = new Worker(\"./workers/transfer-worker.js\", {\n    name: `transfer-worker-original`,\n    type: \"module\",\n  });\n\n  const canvas = document.getElementById(CanvasIds.TRANSFER_CONTROL);\n\n  // TODO: handle resize of the canvas\n\n  const handleResize = event => {\n    console.warn(event);\n    // const { clientWidth, clientHeight } = this.container;\n    console.log(\n      \"handleResize\",\n      // clientWidth,\n      // clientHeight,\n      this\n    );\n    // this.camera.aspect = clientWidth / clientHeight;\n    // this.camera.updateProjectionMatrix();\n    // this.renderer.setSize(clientWidth, clientHeight);\n  };\n\n  window.addEventListener(\"resize\", handleResize);\n\n  const messages = document.querySelector(\".messages ol\");\n\n  const onMessage = event => {\n    const text = `[${NAME} <-- ${event.data.source}] - ${event.data.action}`;\n    const style = \"color: green; font-weight: normal\";\n    console.log(`%c${text}`, style);\n    const li = makeLi({\n      text,\n      style,\n    });\n    messages.appendChild(li);\n    messages.lastChild.scrollIntoView();\n\n    switch (event.data.action) {\n      case WorkerAction.NOTIFY:\n        console.log(event.data.payload.info);\n        break;\n      case WorkerAction.TERMINATE_ME:\n        worker.terminate();\n        console.warn(\"Main thread terminated the worker\");\n        break;\n      default:\n        console.warn(`${NAME} received a message that does not handle`, event);\n    }\n  };\n\n  const onError = event => {\n    console.error(\"Error in web worker\", event);\n    alert(`${event.message} - ${event.filename}. See console for more.`);\n  };\n\n  worker.onmessage = onMessage;\n  worker.onerror = onError;\n\n  // The width and height of the visible canvas will be used to set the size of\n  // WebGL drawing buffer. BUT we cannot create a WebGLRenderingContext with\n  // canvas.getContext(\"webgl\") here because we need to transfer the ownership\n  // of the canvas to the web worker's OffscreenCanvas. If we try to create the\n  // context here we get the following error: Uncaught DOMException: Failed to\n  // execute 'transferControlToOffscreen' on 'HTMLCanvasElement': Cannot\n  // transfer control from a canvas that has a rendering context.\n  // So we create the WebGL rendering context in the web worker.\n  // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n  canvas.setAttribute(\"width\", \"1024\");\n  canvas.setAttribute(\"height\", \"768\");\n  if (!canvas.transferControlToOffscreen) {\n    alert(unsupportedOffscreenCanvasAlertMessage);\n  }\n  const offscreenCanvas = canvas.transferControlToOffscreen();\n  const message = {\n    action: MainThreadAction.INIT_WORKER_STATE,\n    payload: { canvas: offscreenCanvas, sceneName: \"my-scene\" },\n    source: NAME,\n  };\n  const transfer = [offscreenCanvas];\n  worker.postMessage(message, transfer);\n\n  const styleFromWorker = \"color: red; font-weight: normal\";\n  messages.appendChild(\n    makeLi({\n      text: `[${NAME} --> worker] ${message.action}`,\n      style: styleFromWorker,\n    })\n  );\n  messages.lastChild.scrollIntoView();\n\n  const startButton = document.getElementById(ButtonIds.START_RENDER_LOOP);\n  startButton.addEventListener(\"click\", () => {\n    worker.postMessage({\n      action: MainThreadAction.START_RENDER_LOOP,\n      source: NAME,\n    });\n    messages.appendChild(\n      makeLi({\n        text: `[${NAME} --> worker] ${MainThreadAction.START_RENDER_LOOP}`,\n        style: styleFromWorker,\n      })\n    );\n    messages.lastChild.scrollIntoView();\n  });\n\n  const stopButton = document.getElementById(ButtonIds.STOP_RENDER_LOOP);\n  stopButton.addEventListener(\"click\", () => {\n    worker.postMessage({\n      action: MainThreadAction.STOP_RENDER_LOOP,\n      source: NAME,\n    });\n    messages.appendChild(\n      makeLi({\n        text: `[${NAME} --> worker] ${MainThreadAction.STOP_RENDER_LOOP}`,\n        style: styleFromWorker,\n      })\n    );\n    messages.lastChild.scrollIntoView();\n  });\n\n  const terminateButton = document.getElementById(ButtonIds.TERMINATE_WORKER);\n  terminateButton.addEventListener(\"click\", () => {\n    worker.terminate();\n  });\n\n  const instantiateButton = document.getElementById(\n    ButtonIds.INSTANTIATE_WORKER\n  );\n  instantiateButton.addEventListener(\"click\", () => {\n    // We create a new worker but reuse the same variable. Otherwise we would\n    // need to redefine the onmessage and onerror handlers.\n    const workerId = Math.ceil(Math.random() * 1000);\n    worker = new Worker(\"./workers/transfer-worker.js\", {\n      name: `transfer-worker-${workerId}`,\n      type: \"module\",\n    });\n    // It seems that there is no way of getting the control of the canvas back,\n    // so we clone the original canvas and replace it in the DOM with the clone.\n    // https://stackoverflow.com/a/46575483/3036129\n    const oldCanvas = document.getElementById(CanvasIds.TRANSFER_CONTROL);\n    const newCanvas = oldCanvas.cloneNode();\n    oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);\n    // The control of the new, cloned canvas belongs to the main thread, so we\n    // can transfer it to the OffscreenCanvas controlled by the worker.\n    const anotherOffscreenCanvas = newCanvas.transferControlToOffscreen();\n    const msg = {\n      action: MainThreadAction.INIT_WORKER_STATE,\n      payload: { canvas: anotherOffscreenCanvas, sceneName: \"another-scene\" },\n      source: NAME,\n    };\n    worker.postMessage(msg, [anotherOffscreenCanvas]);\n  });\n})();\n","module.exports = __webpack_public_path__ + \"transfer-worker-original.b917bcfd99130bb87963.worker.js\"","module.exports = __webpack_public_path__ + \"2.1d088ca29d3e3703eb68.worker.js\""],"sourceRoot":""}